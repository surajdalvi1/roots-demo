(function() {
  var _ = require('lodash'),
    Contentstack = require('contentstack'),
    path = require('path'),
    RootsUtil = require('roots-util'),
    W = require('when');

  var errors = {
    missing_keys: 'Missing required `api_key` or `access_token` of the Stack!',
    missing_ct_id: 'One or more of your content types is missing its `uid` value'
  };

  module.exports = function(opts) {

    // check for required config
    if (!opts.api_key && !opts.access_token && !opts.environment) {
      console.error('Missing key error | RKiyer');
      throw new Error (errors.missing_keys);
    }

    // setup contentstack SDK
    var Stack = Contentstack.Stack({
// TODO: Find better way to get environment
      environment: opts.environment,
      access_token: opts.access_token,
      api_key: opts.api_key
    });

    return RootsContentstack = (function() {

      function RootsContentstack(roots) {
        var base, base1;
        this.roots = roots;
        this.util = new RootsUtil(this.roots);
        // Not sure what this is!
        if ((base = this.roots.config).locals == null) {
          base.locals = {};
        }
        // Not sure what this is: loads contentstack module into locals, via roots utility, hard to find trace of what all is being called, too nested!
        if ((base1 = this.roots.config.locals).contentstack == null) {
          base1.contentstack = {};
        }
      }


      RootsContentstack.prototype.setup = function() {
        // Need to seperate queries for partials and actual Content types!
        return validate(opts.content_types)["with"](this)
          // .then(process_data)
          .tap(set_urls)
          .tap(set_locals)
          .tap(compile_entries)
          .tap(render_entries);
      };


      validate = function(ctypes) {
        if (_.isPlainObject(ctypes)) {
          // Not sure if this is required | Should be possible without this?
          ctypes = modify_config(ctypes);
        } else {
          // If its not an array
        }
        // This goes through each CT defined in the config file!
        return W.map(ctypes, function(ct) {
          if (!ct.id) {
            return W.reject(errors.missing_keys);
          }
          if (ct.filters == null) {
            ct.filters = {};
          }
          if (ct.name && ct.template && ct.path) {
            var Query = Stack.ContentType(ct.id).Query();
            var keys = Object.keys(ct.filters);
            keys.forEach(function(key) {
              Query[key];
            });
            return W(Query
              .toJSON()
              .find()
              // Is count required?
              .spread(function success(result, count) {
                // Debug
                // console.log('\n-- result --\n');
                // console.log(result);
                if (typeof count !== "undefined") {
                  return {result: result, count: count};
                } else {
                  return result;
                }
              }, function error(err) {
                console.error('SDK call error | RKiyer');
                return err;
              })
              .then(function(res) {
                ct.entries = res;
                return ct;
              }));
          }
          return W.resolve(ct);
        });
      };


      modify_config = function(ctypes) {
        return _.reduce(ctypes, function(res, type, k) {
          type.name = k;
          res.push(type);
          return res;
        }, []);
      };


      /**
       * Sets `_url` and `_urls` properties on content with single entry views
       * `_url` takes the value `null` if the content type's custom path function
       * returns multiple paths
       * @param {Array} types - content type objects
       * return {Promise} - promise when urls are set
       */

      set_urls = function(ctypes) {
        return W.map(ctypes, function(ct) {
          if (ct.template) {
            return W.map(ct.entries, function(entry) {
              var p, paths;
              paths = ct.path(entry);
              if (_.isString(paths)) {
                paths = [paths];
              }
              entry._urls = (function() {
                var i, len, results;
                results = [];
                for (i = 0, len = paths.length; i < len; i++) {
                  p = paths[i];
                  results.push("/" + p + ".html");
                }
                return results;
              })();
              return entry._url = entry._urls.length === 1 ? entry._urls[0] : null;
            });
          }
        });
      };


// Temporary Disabling (un-used)
      // // Need work on this (important!)
      // get_data = function(ctypes) {
      //   return W.map(ctypes, function(obj) {
      //     console.log('Object being queried', obj);
      //     return fetch_entries(obj)
      //       .then(edit_content)
      //       .then(function(c) {
      //         return obj.content = c;
      //       })["yield"](obj);
      //   });
      // };


      // // Filters need to be centralized!
      // fetch_entries = function(ctypes) {
      //   return W(client.entries(_.merge(type.filters, {
      //     content_type: ctype.id,
      //     include: 10
      //   })));
      // };


      // Do user defined functions on the data being fetched
      // process_data = function(ctypes) {
      //   // process data here!
      //   return W(function() {
      //     return ctypes;
      //   });
      // };

      set_locals = function(ctypes) {
        return W.map(ctypes, (function(_this) {
          return function(ct) {
            return _this.roots.config.locals.contentstack[ct.name] = ct.entries;
          };
        })(this));
      };


      /**
       * Compiles single entry views for content types
       * @param {Array} types - Populated content type objects
       * @return {Promise} - promise for when compilation is finished
       */

      compile_entries = function(ctypes) {
        // Debug
        // console.log('\n-- roots.config.locals.contentstack --\n');
        // console.log(this.roots.config.locals.contentstack);
        // --
        // console.log('\n Compile Object \n');
        // console.log(ctypes);
        // console.log('--');

        return W.map(ctypes, (function(_this) {
          return function(ct) {

            if (!ct.template) {
              // Template check was done before: Let's throw template error?
              return W.resolve();
            }
            // Iterate over each entry object
            return W.map(ct.entries, function(entry) {
              // Debug entry object
              // console.log('\n-- Transformed Entry --\n');
              // console.log(entry);

              var compiler, template;
              template = path.join(_this.roots.root, ct.template);
              compiler = _.find(_this.roots.config.compilers, function(c) {
              // Why substring(1)
              // Check roots for the same: path.extname(template).substring(1)
                return _.contains(c.extensions, path.extname(template).substring(1));
              });
              return W.map(entry._urls, function(url) {
                _this.roots.config.locals.entry = _.assign({}, entry, {
                  _url: url
                });
                return compiler.renderFile(template, _this.roots.config.locals).then(function(res) {
                  _this.roots.config.locals.entry = null;
                  return _this.util.write(url, res.result);
                });
              });
            });
          };
        })(this));
      };


      /**
       * Writes all data for type with content as json
       * @param {Array} types - Populated content type objects
       * @return {Promise} - promise for when compilation is finished
       */

      render_entries = function(ctypes) {
        // Debug
        // console.log('\n-- write --\n');
        // console.log(types);
        return W.map(ctypes, (function(_this) {
          return function(ct) {
            if (!ct.write) {
              return W.resolve();
            }
            return _this.util.write(ct.write, JSON.stringify(ct.entries));
          };
        })(this));
      };

      return RootsContentstack;

    })();
  };
}).call(this);