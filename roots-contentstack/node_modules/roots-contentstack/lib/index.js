(function() {
  var _ = require('lodash'),
    Contentstack = require('contentstack'),
    path = require('path'),
    RootsUtil = require('roots-util'),
    W = require('when'),
    nunjucks = require('nunjucks');

  var errors = {
    missing_keys: 'Missing required `api_key` or `access_token` of the Stack!',
    missing_ct_id: 'One or more of your content types is missing its `uid` value'
  };

  /**
   * Exports roots-contentstack module
   * @param  {Object} opts Configuration object
   * @return {Object} RootsContentstack
   */
  module.exports = function(opts) {

    /**
     * Check if the essentials keys to make SDK calls to Contentstack application are present
     */
    if (!opts.api_key && !opts.access_token && !opts.environment) {
      throw new Error (errors.missing_keys);
    }


    /**
     * Initialize Contentstack SDK script
     * @type {Object} SDK object to make queries on Contentstack server
     */

    var Stack = Contentstack.Stack({
      environment: opts.environment,
      access_token: opts.access_token,
      api_key: opts.api_key
    });


    return RootsContentstack = (function() {


      /**
       * Initialize the extension, and load locals and contentstack onto it
       * @param {Object} roots, is an instance of Roots
       */

      function RootsContentstack(roots) {
        var base, base1;
        this.roots = roots;
        // load current instance of roots
        this.util = new RootsUtil(this.roots);
        if ((base = this.roots.config).locals == null) {
          base.locals = {};
        }
        // loading contentstack module onto locals
        if ((base1 = this.roots.config.locals).contentstack == null) {
          base1.contentstack = {};
        }
      }


      /**
       * Handles the workflow of the application
       * @return {Promise} determines the status of the application
       */

      RootsContentstack.prototype.setup = function() {
        // TODO: Need to seperate queries for partials and actual Content types!
        return checkEssentials(opts.content_types)["with"](this)
          // .then(process_data)
          .tap(set_urls)
          .tap(set_locals)
          .tap(compile_entries)
          .tap(render_entries);
      };


      /**
       * Check if the required info on the content type being fetched on exists
       * @param  {Object} ctypes - content_types set in app.coffee extension config
       * @return {Promise}       - returns an array of configured content types
       */

      checkEssentials = function(ctypes) {
        if (_.isPlainObject(ctypes)) {
          ctypes = arrayify(ctypes);
        }

        return W.map(ctypes, function(ct) {
          if (!ct.id || !ct.template) {
            return W.reject(errors.missing_keys);
          }
          if (ct.filters == null) {
            ct.filters = {};
          }
          if (ct.name && ct.template && ct.path) {
            var Query = Stack.ContentType(ct.id).Query();
            var keys = Object.keys(ct.filters);
            keys.forEach(function(key) {
              Query[key];
            });
            return W(Query
              .toJSON()
              .find()
              .spread(function success(result, count) {
                if (typeof count !== "undefined") {
                  return {result: result, count: count};
                } else {
                  return result;
                }
              }, function error(err) {
                console.error('SDK call error', err);
                return err;
              })
              .then(function(res) {
                ct.entries = res;
                return ct;
              }));
          }
          return W.resolve(ct);
        });
      };


      /**
       * Reconfigures content types set in app.coffee using an object instead of
       * an array. The keys of the object set as the `name` option in the config
       * @param {Object} ctypes - content_types set in app.coffee extension config
       * @return {Promise} - returns an array of content types
       */

      arrayify = function(ctypes) {
        return _.reduce(ctypes, function(res, type, k) {
          type.name = k;
          res.push(type);
          return res;
        }, []);
      };


      /**
       * Sets `_url` and `_urls` properties on content with single entry views
       * `_url` takes the value `null` if the content type's custom path function
       * returns multiple paths
       * @param {Array} types - content type objects
       * return {Promise} - promise when urls are set
       */

      set_urls = function(ctypes) {
        return W.map(ctypes, function(ct) {
          if (ct.template) {
            return W.map(ct.entries, function(entry) {
              var p, paths;
              paths = ct.path(entry);
              if (_.isString(paths)) {
                paths = [paths];
              }
              entry._urls = (function() {
                var i, len, results;
                results = [];
                for (i = 0, len = paths.length; i < len; i++) {
                  p = paths[i];
                  results.push("/" + p + ".html");
                }
                return results;
              })();
              return entry._url = entry._urls.length === 1 ? entry._urls[0] : null;
            });
          }
        });
      };

      // // Filters need to be centralized!
      // fetch_entries = function(ctypes) {
      //   return W(client.entries(_.merge(type.filters, {
      //     content_type: ctype.id,
      //     include: 10
      //   })));
      // };

      // Do user defined functions on the data being fetched
      // process_data = function(ctypes) {
      //   // process data here!
      //   return W(function() {
      //     return ctypes;
      //   });
      // };


      /**
       * Builds locals object from types objects with content
       * @param {Array} ctypes - populated content type objects
       * @return {Promise} - promise for when complete
       */

      set_locals = function(ctypes) {
        return W.map(ctypes, (function(_this) {
          return function(ct) {
            return _this.roots.config.locals.contentstack[ct.name] = ct.entries;
          };
        })(this));
      };


      /**
       * Compiles single entry views for content types
       * @param {Array} types - Populated content type objects
       * @return {Promise} - promise for when compilation is finished
       */

      compile_entries = function(ctypes) {
        return W.map(ctypes, (function(_this) {
          return function(ct) {
            if (!ct.template) {
              return W.resolve();
            }
            return W.map(ct.entries, function(entry) {
              var compiler, template;
              template = path.join(_this.roots.root, ct.template);
              compiler = _.find(_this.roots.config.compilers, function(c) {
              // Why substring(1)
              // Check roots for the same: path.extname(template).substring(1)
                return _.contains(c.extensions, path.extname(template).substring(1));
              });
              return W.map(entry._urls, function(url) {
                _this.roots.config.locals.entry = _.assign({}, entry, {
                  _url: url
                });

                var keys = Object.keys(_this.roots.config.locals.contentstack);
                keys.forEach(function(ct) {
                  if(_.isArray(_this.roots.config.locals.contentstack[ct])) {
                    _this.roots.config.locals.contentstack[ct].forEach(function(entry) {
                      if(compiler) {
                        return compiler.renderFile(template, entry)
                          .then(function(res) {
                            return _this.util.write(url, res.result);
                          });
                      } else {
                        return nunjucks.render(template, entry, function(err, res) {
                          if(err)
                            console.error(err);
                          _this.roots.config.locals.entry = null;
                          return _this.util.write(url, res);
                        })
                      }
                    })
                  }
                })
              });
            });
          };
        })(this));
      };


      /**
       * Writes all data for type with content as json
       * @param {Array} types - Populated content type objects
       * @return {Promise} - promise for when compilation is finished
       */

      render_entries = function(ctypes) {
        return W.map(ctypes, (function(_this) {
          return function(ct) {
            if (!ct.write) {
              return W.resolve();
            }
            return _this.util.write(ct.write, JSON.stringify(ct.entries));
          };
        })(this));
      };

      return RootsContentstack;

    })();
  };
}).call(this);
